/**
高阶指南
  响应性：
    1.深入响应性原理
      1-1.什么是响应性（v-model）
          ** 是一种允许我们以声明式的方式去适应变化的编程范例。
              Q：那么我们如何用 JavaScript 实现这一点呢？
              A：检测其中某一个值是否发生变化
                -> 用跟踪 (track) 函数修改值
                -> 用触发 (trigger) 函数更新为最新的值

      1-2.vue如何知道哪些代码再执行?
          ** Vue 通过一个副作用 (effect) 来跟踪当前正在运行的函数。
            副作用是一个函数的包裹器，在函数被调用之前就启动跟踪。
            Vue 知道哪个副作用在何时运行，并能在需要时再次执行它。
      
      1-3.vue如何跟踪变化
          ** 跟踪对象 property 的变化。
          ** Proxy 是一个对象，它包装了另一个对象，并允许你拦截对该对象的任何交互。
            -> 读值时的跟踪：proxy 的 get 处理函数中 track 函数记录了该 property 和当前副作用。
            -> 检测该值何时发生变化：在 proxy 上调用 set 处理函数。
            -> 触发函数以便它可以更新最终值：trigger 函数查找哪些副作用依赖于该 property 和它们的执行。
          被代理的对象
            ** Vue 在内部跟踪所有已经被转成响应式的对象，所以它总是为同一个对象返回相同的代理。

          Proxy vs 原始标识
            ** Proxy 的使用确实引入了一个需要注意的新警告：在身份比较方面，被代理对象与原始对象不相等 (===)。
                const obj = {}
                const wrapped = new Proxy(obj, handlers)
                console.log(obj === wrapped) // false
            请注意，Vue 不会在 Proxy 中包裹数字或字符串等原始值，所以你仍然可以对这些值直接使用 === 来比较

      1-4.如何让渲染相应变化
            ** 将组件模板编译成一个render函数，并包裹到一个副作用中，允许 Vue 在运行时跟踪被“触发”的property。如果这些property中的任何一个发生变化，将触发副作用再次运行，重新运行 render 函数以生成新的 VNodes。然后这些举动被用来对 DOM 进行必要的修改。

    2.响应性基础
      @toLearn
    3.响应式计算和侦听
      @toLearn
  渲染机制和优化
    @toLearn
  vue2中的更改检测报告
    @略
 */


